resolution <- 4 ## set to 4 for quarterly resolution
sample_years <- 2009:2012
serosolver::describe_priors()
prior_version <- 2
## Read in titre data
# unvaccinated
input_dat_path <- system.file("extdata", "HKdata_h1n1_unvac.csv", package = "serosolver")
input_dat <- read.csv(file = input_dat_path, header = TRUE)
# vaccinated
# input_dat_path2 <- system.file("extdata", "HKdata_h1n1_vac.csv", package = "serosolver")
# input_dat_vac <- read.csv(file = input_dat_path2, header = TRUE)
indivs <- unique(input_dat$individual) #all individuals
# Subset data for indivs
titre_dat <- input_dat[input_dat$individual %in% indivs,
c("individual","virus","titre","samples","DOB")]
titre_dat$individual <- match(titre_dat$individual, indivs)
titre_dat <- unique(titre_dat)
titre_dat <- plyr::ddply(titre_dat,.(individual,virus,samples),
function(x) cbind(x,"run"=1:nrow(x),"group"=1))
print(head(titre_dat))
strain_isolation_times <- seq(sample_years[1]*resolution+1, sample_years[4]*resolution, by=1)
par_tab_path <- system.file("extdata", "par_tab_base.csv", package = "serosolver")
par_tab <- read.csv(par_tab_path, stringsAsFactors=FALSE)
## Set parameters for beta and alpha to 1
par_tab[par_tab$names %in% c("alpha","beta"),"values"] <- c(1/3,1/3)
## Maximum recordable log titre in these data is 9
par_tab[par_tab$names == "MAX_TITRE","values"] <- 9
## Remove phi parameters, as these are integrated out under prior version 2
par_tab <- par_tab[par_tab$names != "phi",]
## Fix cross reactivity and antigenic seniority
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"fixed"] <- 1
## mu, tau, sigma1, and sigma2 are fixed
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"values"] <- 0
## set these values to 0
## Distinct filename for each chain
no_chains <- 5
filenames <- paste0(filename, "_",1:no_chains)
chain_path <- sub("par_tab_base.csv","",par_tab_path)
chain_path_real <- paste0(chain_path, "cs1_real/")
chain_path_sim <- paste0(chain_path, "cs1_sim/")
## Create the posterior solving function that will be used in the MCMC framework
par_tab[par_tab$names == "mu_short","lower_bound"] <- 1
model_func <- create_posterior_func(par_tab=par_tab,
titre_dat=titre_dat,
strain_isolation_times = strain_isolation_times,
version=prior_version) # function in posteriors.R
# Required to run serosolver
devtools::install_github("seroanalytics/serosolver", force = TRUE)
library(serosolver)
library(plyr)
library(data.table)
## Required for this analysis
library(reshape2)
library(foreach)
library(doParallel)
library(bayesplot)
library(coda)
library(ggplot2)
library(viridis)
library(ggpubr)
# set up cluster
set.seed(0)
cl <- makeCluster(5)
if(Sys.info()[["sysname"]]=="Darwin" | Sys.info()[["sysname"]]=="Linux"){
library(doMC)
library(doRNG)
registerDoMC(cores=5)
}else{
registerDoParallel(cl)
}
filename <- "case_study_1"
resolution <- 4 ## set to 4 for quarterly resolution
sample_years <- 2009:2012
serosolver::describe_priors()
prior_version <- 2
## Read in titre data
# unvaccinated
input_dat_path <- system.file("extdata", "HKdata_h1n1_unvac.csv", package = "serosolver")
input_dat <- read.csv(file = input_dat_path, header = TRUE)
indivs <- unique(input_dat$individual) #all individuals
# Subset data for indivs
titre_dat <- input_dat[input_dat$individual %in% indivs,
c("individual","virus","titre","samples","DOB")]
titre_dat$individual <- match(titre_dat$individual, indivs)
titre_dat <- unique(titre_dat)
titre_dat <- plyr::ddply(titre_dat,.(individual,virus,samples),
function(x) cbind(x,"run"=1:nrow(x),"group"=1))
print(head(titre_dat))
strain_isolation_times <- seq(sample_years[1]*resolution+1, sample_years[4]*resolution, by=1)
par_tab_path <- system.file("extdata", "par_tab_base.csv", package = "serosolver")
par_tab <- read.csv(par_tab_path, stringsAsFactors=FALSE)
## Set parameters for beta and alpha to 1
par_tab[par_tab$names %in% c("alpha","beta"),"values"] <- c(1/3,1/3)
## Maximum recordable log titre in these data is 9
par_tab[par_tab$names == "MAX_TITRE","values"] <- 9
## Remove phi parameters, as these are integrated out under prior version 2
par_tab <- par_tab[par_tab$names != "phi",]
## Fix cross reactivity and antigenic seniority
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"fixed"] <- 1
## mu, tau, sigma1, and sigma2 are fixed
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"values"] <- 0
## Distinct filename for each chain
no_chains <- 5
filenames <- paste0(filename, "_",1:no_chains)
chain_path <- sub("par_tab_base.csv","",par_tab_path)
chain_path_real <- paste0(chain_path, "cs1_real/")
chain_path_sim <- paste0(chain_path, "cs1_sim/")
## Create the posterior solving function that will be used in the MCMC framework
par_tab[par_tab$names == "mu_short","lower_bound"] <- 1
model_func <- create_posterior_func(par_tab=par_tab,
titre_dat=titre_dat,
strain_isolation_times = strain_isolation_times,
version=prior_version) # function in posteriors.R
devtools::install_github("seroanalytics/serosolver", ref = "published", force = TRUE)
## Required for this analysis
library(serosolver)
library(reshape2)
library(foreach)
library(doParallel)
library(bayesplot)
library(coda)
library(ggplot2)
library(viridis)
library(ggpubr)
library(lubridate)
library(here)
library(readxl)
library(dplyr)
library(tidyverse)
# set up cluster
set.seed(0)
cl <- makeCluster(5)
if(Sys.info()[["sysname"]]=="Darwin" | Sys.info()[["sysname"]]=="Linux"){
library(doMC)
library(doRNG)
registerDoMC(cores=5)
}else{
registerDoParallel(cl)
}
serosolver::describe_priors()
# Set the prior version
prior_version <- 2
#import data
chikdata <- read_excel(here("Data", "chikungunya_data_Uganda.xlsx"))
chikdata$titre <- NA_real_
# Assign low titres to seronegative individuals
chikdata$titre[chikdata$IgM_CHIK == "Negative"] <- runif(
sum(chikdata$IgM_CHIK == "Negative"), min = 0, max = 10
)
# Assigning higher titres to seropositive individuals
chikdata$titre[chikdata$IgM_CHIK == "Positive"] <- rlnorm(
sum(chikdata$IgM_CHIK == "Positive"), meanlog = log(40), sdlog = 0.4
)
#select relevant columns
chikdata<- chikdata %>%  select(UniqueKey, Age_Yrs, Year,IgM_CHIK, titre) %>% dplyr::rename(DOB = Age_Yrs)
#recode Nengative to Negative
chikdata$IgM_CHIK[chikdata$IgM_CHIK == "Nengative"] <- "Negative"
# Recode "NA" string to actual NA
chikdata$IgM_CHIK[chikdata$IgM_CHIK == "NA"] <- NA
# Drop all real NA values
chikdata <- chikdata[!is.na(chikdata$IgM_CHIK), ]
chikdata <- chikdata %>% dplyr::rename(individual = UniqueKey)
chikdata <- chikdata %>% select(individual,DOB,titre)
chikdata <- chikdata[!is.na(chikdata$DOB), ]
chikdata$individual <- as.integer(chikdata$individual)
chikdata$titre <- round(chikdata$titre, 2)
filename <- "chik_2019"
resolution <- 4 # Resolution of the serosurvey, on quartely basis
sample_year <- 2019: 2022 # Year of the serosurvey
# Create a sequence of sample years
years <- 2019:2022
# Create a sequence of sample years for each individual
chikdata <- chikdata %>%
slice(rep(1:n(), each = 4)) %>%
mutate(year = rep(years, times = nrow(chikdata)))
set.seed(123)
# Randomly assign titres to each quarter
chikdata <- chikdata %>%
group_by(individual) %>%
mutate(
titre = round(titre * runif(n(), 0.9, 1.1), 2)
) %>%
ungroup()
# Create a virus column and assign a year of isolation
chikdata$virus <- 8077
set.seed(123)  # For reproducibility
chikdata <- chikdata %>%
mutate(
quarter = sample(1:4, size = n(), replace = TRUE),
samples = (year + (quarter - 1) / 4) * 4 + 1,
samples = as.integer(samples)
)
# Convert DOB to Date format and compute age
chikdata <- chikdata %>%
mutate(
DOB = as.Date(DOB),                        # convert to Date format
birth_year = year(DOB),                    # extract year
age = 2019 - birth_year,                   # compute age in 2019
DOB = (birth_year * 4) + 1   # convert to sample time format
)
indivs <- unique(chikdata$individual) #all individuals
# Subset data for indivs
chikdata <- plyr::ddply(
chikdata,
~ individual + virus + samples,
function(x) cbind(x, "run" = 1:nrow(x), "group" = 1)
)
chikdata$individual <- match(chikdata$individual, indivs)
print(head(chikdata))
# Convert virus, titre, and DOB to integer
chikdata <- chikdata %>%
mutate(
virus = as.integer(virus),
titre = as.integer(titre),
DOB = as.integer(DOB)
)
#convert titre to log2 scale
chikdata$titre <- log2(chikdata$titre)
strain_isolation_times <- seq(sample_years[1]*resolution+1, sample_years[4]*resolution, by=1)
par_tab_path <- system.file("extdata", "par_tab_base.csv", package = "serosolver")
par_tab <- read.csv(par_tab_path, stringsAsFactors=FALSE)
## Set parameters for beta and alpha to 1
par_tab[par_tab$names %in% c("alpha","beta"),"values"] <- c(1/3,1/3)
## Maximum recordable log titre in these data is 9
par_tab[par_tab$names == "MAX_TITRE","values"] <- 9
## Remove phi parameters, as these are integrated out under prior version 2
par_tab <- par_tab[par_tab$names != "phi",]
## Fix cross reactivity and antigenic seniority
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"fixed"] <- 1
## mu, tau, sigma1, and sigma2 are fixed
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"values"] <- 0
## set these values to 0
#possible exposure times
possible_exposure_times <- seq(1928,2022,by=1)
## Distinct filename for each chain
no_chains <- 5
filenames <- paste0(filename, "_",1:no_chains)
chain_path <- sub("par_tab_base.csv","",par_tab_path)
chain_path_real <- paste0(chain_path, "cs1_real/")
chain_path_sim <- paste0(chain_path, "cs1_sim/")
## Create the posterior solving function that will be used in the MCMC framework
par_tab[par_tab$names == "mu_short","lower_bound"] <- 1
model_func <- create_posterior_func(par_tab=par_tab,
chikdata,
antigenic_map=NULL,
strain_isolation_times = strain_isolation_times,
version=prior_version)
## Generate results in parallel
res <- foreach(x = filenames, .packages = c('serosolver','data.table','plyr')) %dopar% {
## Not all random starting conditions return finite likelihood, so for each chain generate random
## conditions until we get one with a finite likelihood
start_prob <- -Inf
while(!is.finite(start_prob)){
## Generating starting antibody kinetics parameters
start_tab <- generate_start_tab(par_tab)
## Generate starting infection history
start_inf <- setup_infection_histories_titre(chikdata, strain_isolation_times,
space=3,titre_cutoff=4)
start_prob <- sum(model_func(start_tab$values, start_inf)[[1]])
}
res <- run_MCMC(par_tab = start_tab,
titre_dat = chikdata,
antigenic_map = NULL,
strain_isolation_times = strain_isolation_times,
start_inf_hist = start_inf,
mcmc_pars = c("iterations"=2000000,"popt"=0.44,"popt_hist"=0.44,
"opt_freq"=1000,"thin"=1,"adaptive_period"=500000,
"save_block"=1000, "thin_hist"=100,"hist_sample_prob"=1,
"switch_sample"=2, "burnin"=0, "inf_propn"=0.5,
"move_size"=3,"hist_opt"=1,"swap_propn"=0.5,
"hist_switch_prob"=0.5,"year_swap_propn"=1),
filename = paste0(chain_path_real,x),
CREATE_POSTERIOR_FUNC = create_posterior_func,
version = prior_version)
}
## Generate results in parallel
res <- foreach(x = filenames, .packages = c('serosolver','data.table','plyr')) %dopar% {
## Not all random starting conditions return finite likelihood, so for each chain generate random
## conditions until we get one with a finite likelihood
start_prob <- -Inf
while(!is.finite(start_prob)){
## Generating starting antibody kinetics parameters
start_tab <- generate_start_tab(par_tab)
## Generate starting infection history
start_inf <- setup_infection_histories_titre(chikdata, strain_isolation_times,
space=3,titre_cutoff=4)
start_prob <- sum(model_func(start_tab$values, start_inf)[[1]])
}
res <- run_MCMC(par_tab = start_tab,
titre_dat = chikdata,
antigenic_map = NULL,
strain_isolation_times = strain_isolation_times,
start_inf_hist = start_inf,
mcmc_pars = c("iterations"=2000000,"popt"=0.44,"popt_hist"=0.44,
"opt_freq"=1000,"thin"=1,"adaptive_period"=500000,
"save_block"=1000, "thin_hist"=100,"hist_sample_prob"=1,
"switch_sample"=2, "burnin"=0, "inf_propn"=0.5,
"move_size"=3,"hist_opt"=1,"swap_propn"=0.5,
"hist_switch_prob"=0.5,"year_swap_propn"=1),
filename = paste0(chain_path_real,x),
CREATE_POSTERIOR_FUNC = create_posterior_func,
version = prior_version)
}
## Generate results in parallel
res <- foreach(x = filenames, .packages = c('serosolver','data.table','plyr')) %dopar% {
## Not all random starting conditions return finite likelihood, so for each chain generate random
## conditions until we get one with a finite likelihood
start_prob <- -Inf
while(!is.finite(start_prob)){
## Generating starting antibody kinetics parameters
start_tab <- generate_start_tab(par_tab)
## Generate starting infection history
start_inf <- setup_infection_histories_titre(chikdata, strain_isolation_times,
space=3,titre_cutoff=4)
start_prob <- sum(model_func(start_tab$values, start_inf)[[1]])
}
res <- run_MCMC(par_tab = start_tab,
titre_dat = chikdata,
antigenic_map = NULL,
strain_isolation_times = strain_isolation_times,
start_inf_hist = start_inf,
mcmc_pars = c("iterations"=2000000,"popt"=0.44,"popt_hist"=0.44,
"opt_freq"=1000,"thin"=1,"adaptive_period"=500000,
"save_block"=1000, "thin_hist"=100,"hist_sample_prob"=1,
"switch_sample"=2, "burnin"=0, "inf_propn"=0.5,
"move_size"=3,"hist_opt"=1,"swap_propn"=0.5,
"hist_switch_prob"=0.5,"year_swap_propn"=1),
filename = paste0(chain_path_real,x),
CREATE_POSTERIOR_FUNC = create_posterior_func,
version = prior_version)
}
# Required to run serosolver
devtools::install_github("seroanalytics/serosolver", ref = "published", force = TRUE)
library(serosolver)
library(plyr)
library(data.table)
## Required for this analysis
library(reshape2)
library(foreach)
library(doParallel)
library(bayesplot)
library(coda)
library(ggplot2)
library(viridis)
library(ggpubr)
# set up cluster
set.seed(0)
cl <- makeCluster(5)
if(Sys.info()[["sysname"]]=="Darwin" | Sys.info()[["sysname"]]=="Linux"){
library(doMC)
library(doRNG)
registerDoMC(cores=5)
}else{
registerDoParallel(cl)
}
filename <- "case_study_1"
resolution <- 4 ## set to 4 for quarterly resolution
sample_years <- 2009:2012
serosolver::describe_priors()
prior_version <- 2
## Read in titre data
# unvaccinated
input_dat_path <- system.file("extdata", "HKdata_h1n1_unvac.csv", package = "serosolver")
input_dat <- read.csv(file = input_dat_path, header = TRUE)
indivs <- unique(input_dat$individual) #all individuals
# Subset data for indivs
titre_dat <- input_dat[input_dat$individual %in% indivs,
c("individual","virus","titre","samples","DOB")]
titre_dat$individual <- match(titre_dat$individual, indivs)
titre_dat <- unique(titre_dat)
titre_dat <- plyr::ddply(titre_dat,.(individual,virus,samples),
function(x) cbind(x,"run"=1:nrow(x),"group"=1))
print(head(titre_dat))
strain_isolation_times <- seq(sample_years[1]*resolution+1, sample_years[4]*resolution, by=1)
par_tab_path <- system.file("extdata", "par_tab_base.csv", package = "serosolver")
par_tab <- read.csv(par_tab_path, stringsAsFactors=FALSE)
## Set parameters for beta and alpha to 1
par_tab[par_tab$names %in% c("alpha","beta"),"values"] <- c(1/3,1/3)
## Maximum recordable log titre in these data is 9
par_tab[par_tab$names == "MAX_TITRE","values"] <- 9
## Remove phi parameters, as these are integrated out under prior version 2
par_tab <- par_tab[par_tab$names != "phi",]
## Fix cross reactivity and antigenic seniority
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"fixed"] <- 1
## mu, tau, sigma1, and sigma2 are fixed
par_tab[par_tab$names %in% c("tau","sigma1","sigma2"),"values"] <- 0
## Distinct filename for each chain
no_chains <- 5
filenames <- paste0(filename, "_",1:no_chains)
chain_path <- sub("par_tab_base.csv","",par_tab_path)
chain_path_real <- paste0(chain_path, "cs1_real/")
chain_path_sim <- paste0(chain_path, "cs1_sim/")
## Create the posterior solving function that will be used in the MCMC framework
par_tab[par_tab$names == "mu_short","lower_bound"] <- 1
model_func <- create_posterior_func(par_tab=par_tab,
titre_dat=titre_dat,
strain_isolation_times = strain_isolation_times,
version=prior_version) # function in posteriors.R
## Generate results in parallel
res <- foreach(x = filenames, .packages = c('serosolver','data.table','plyr')) %dopar% {
## Not all random starting conditions return finite likelihood, so for each chain generate random
## conditions until we get one with a finite likelihood
start_prob <- -Inf
while(!is.finite(start_prob)){
## Generating starting antibody kinetics parameters
start_tab <- generate_start_tab(par_tab)
## Generate starting infection history
start_inf <- setup_infection_histories_titre(titre_dat, strain_isolation_times,
space=3,titre_cutoff=4)
start_prob <- sum(model_func(start_tab$values, start_inf)[[1]])
}
res <- run_MCMC(par_tab = start_tab,
titre_dat = titre_dat,
antigenic_map = NULL,
strain_isolation_times = strain_isolation_times,
start_inf_hist = start_inf,
mcmc_pars = c("iterations"=2000000,"popt"=0.44,"popt_hist"=0.44,
"opt_freq"=1000,"thin"=1,"adaptive_period"=500000,
"save_block"=1000, "thin_hist"=100,"hist_sample_prob"=1,
"switch_sample"=2, "burnin"=0, "inf_propn"=0.5,
"move_size"=3,"hist_opt"=1,"swap_propn"=0.5,
"hist_switch_prob"=0.5,"year_swap_propn"=1),
filename = paste0(chain_path_real,x),
CREATE_POSTERIOR_FUNC = create_posterior_func,
version = prior_version)
}
view(input_dat)
view(titre_dat)
lookup("dnorm")
install.packages("Rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
install.packages("stan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
install.packages("stan")
install.packages("Rstan")
install.packages("rstan")
library(rstan)
lookup("dnorm")
args(serosolver)
library(serosolver)
args(serosolver)
?serosolver
lookup("stan")
lookup("rstan")
lookup("stan")
lookup(serosolver)
## Set parameters for beta and alpha to 1
par_tab[par_tab$names %in% c("alpha","beta"),"values"] <- c(1/3,1/3)
par_tab_path <- system.file("extdata", "par_tab_base.csv", package = "serosolver")
par_tab <- read.csv(par_tab_path, stringsAsFactors=FALSE)
view(par_tab)
str(par_tab)
## Read in the MCMC chains
# Note that `thin` here is in addition to any thinning done during the fitting
# Chain length values in load function need to be consistent with MCMC run
#all_chains <- load_mcmc_chains(location=chain_path_real,thin=100,burnin=500000,
#                             par_tab=par_tab,unfixed=FALSE,convert_mcmc=TRUE)
## Alternative, load the included MCMC chains rather than re-running
data(cs1_chains_real)
all_chains <- cs1_chains_real
print(summary(all_chains))
## Get the MCMC chains as a list
list_chains <- all_chains$theta_list_chains
## Look at diagnostics for the free parameters
list_chains1 <- lapply(list_chains, function(x) as.mcmc(x[,c("mu","mu_short", "wane",
"error", "total_infections",
"lnlike", "prior_prob")]))
## Gelman-Rubin diagnostics to assess between-chain convergence for each parameter
print(gelman.diag(as.mcmc.list(list_chains1)))
gelman.plot(as.mcmc.list(list_chains1))
## Effective sample size for each parameter
print(effectiveSize(as.mcmc.list(list_chains1)))
## Posterior estimates for each parameter
print(summary(as.mcmc.list(list_chains1)))
strain_isolation_times
syc.Date
Sys.Date()
Sys.time()
3*800
2400+4*350
getwd()
install.packages("haven")
library(haven)
library(dplyr)
Asembodata <- read_dta("Asembo PBIDS arbo.dta")
Asembodata <- read_dta("Asembo PBIDS arbo.dta")
Asembodata <- read_dta("Asembo PBIDS arbo.dta")
head(Asembodata)
View(Asembodata)
colnames(Asembodata)
table(Asembodata$CHKpos)
is.na(Asembodata)
sum(is.na(Asembodata))
length(unique(Asembodata$sample_id))
View(Asembodata)
table(Asembodata$sex)
table(Asembodata$CHKpos, Asembodata$sex)
tableby(CHIKpos ~ sex., data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
install.packages("arsenal")
library(arsenal)
tableby(CHIKpos ~ sex., data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
tableby(CHKpos ~ sex., data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
tableby(CHKpos ~ sex, data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
tableby(CHKpos ~ sex + agecat, data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
colnames(Asembodata)
tableby(CHKpos ~ sex + ageyrs, data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
tableby(CHKpos ~ ageyrs, data = Asembodata) %>%
summary(text = TRUE, title = "Asembo Arbovirus Study")
